plot_bgcolor='#e5ecf6')
fig
#| label: fig-muertespdf
#| fig-cap: "Serie de tiempo de los casos de muerte por COVID-19 en Irán del 20-02-2020 al 15-08-2020"
plot(Deaths_ts)
#| label: tbl-forecastdpdf
#| tbl-cap: "Comparación de Resultados entre las técnicas y los datos reales para evaluar precisión"
dfor <- data.frame(Date=Deaths_df$Date[126:178],
Real= test_deaths,
Forecast_HW=HWd_for$mean,
Forecast_MLP=frcd$mean)
library(zoo,warn.conflicts=FALSE)
library(lubridate,warn.conflicts=FALSE)
library(mgcv,warn.conflicts=FALSE)
library(rugarch,warn.conflicts=FALSE)
# visualization
suppressPackageStartupMessages(library(ggplot2))
# getting financial data
suppressPackageStartupMessages(library(quantmod))
# calculating returns
suppressPackageStartupMessages(library(PerformanceAnalytics))
# GARCH modeling
suppressPackageStartupMessages(library(rugarch))
# ARCH test
suppressPackageStartupMessages(library(FinTS))
# ARMA modeling
suppressPackageStartupMessages(library(forecast))
# structural changes
suppressPackageStartupMessages(library(strucchange))
# ARMA order identification
suppressPackageStartupMessages(library(TSA))
library(tseries)
library(timeSeries)
library(tswge)
library(xts)
library(pastecs)
library(tidyr)
library(dplyr)
library(dygraphs)
library(splines)
library(kableExtra)
library(conflicted)
library(goeveg)
library(tidyverse)
rm(list=ls())
library(FinTS)
library(rugarch)
library(tseries)
library(dynlm)
library(vars)
library(nlWaldTest)
library(broom)
library(readxl)
library(plotly)
library(nnfor)
library(neuralnet)
# Importamos la base de datos total
COVID.19.global.data <- read.csv("WHO-COVID-19-global-data.csv")
#Dataframe de los casos confirmados en Irán
COVID.IRAN_d <- data.frame(Date=COVID.19.global.data$Date_reported[108535:108742],
Deaths=COVID.19.global.data$New_deaths[108535:108742])
#Dataframe de los casos confirmados en Irán del 20-02-2020 al 15-08-2020
Deaths_df <- data.frame(COVID.IRAN_d[1:178,])
#Función para eliminar los ceros (por interpolación promedio)
for (i in 2:length(Deaths_df$Date)-1) {
if (Deaths_df$Deaths[i]==0) {
Deaths_df$Deaths[i] <- (Deaths_df$Deaths[i-1]+
Deaths_df$Deaths[i+1])/2}}
inds <- seq(as.Date("2020-02-20"), as.Date("2020-08-15"), by = "day")
# Se crea un objeto 'serie de tiempo' de frecuencia diaria
Deaths_ts <- ts(Deaths_df[2],
start = c(2020, as.numeric(format(inds[1], "%j"))),
frequency = 365)
fig <- plot_ly(Deaths_df, type = 'scatter', mode = 'lines')%>%
add_trace(x = ~Date, y = ~Deaths)%>%
plotly::layout(showlegend = F)
fig <- fig %>%
plotly::layout(
xaxis = list(zerolinecolor = '#ffff',
zerolinewidth = 2,
gridcolor = 'ffff'),
yaxis = list(zerolinecolor = '#ffff',
zerolinewidth = 2,
gridcolor = 'ffff'),
plot_bgcolor='#e5ecf6')
fig
#| label: fig-muertespdf
#| fig-cap: "Serie de tiempo de los casos de muerte por COVID-19 en Irán del 20-02-2020 al 15-08-2020"
plot(Deaths_ts)
Deaths_ts <- ts(Deaths_ts,frequency=1)
tsize <- round(0.7 * nrow(Deaths_df))
train_deaths <- window(Deaths_ts,end=tsize)
test_deaths <- window(Deaths_ts,start=tsize+1)
##### HW #####
HWd <- HoltWinters(ts(train_deaths,frequency = 2), seasonal = 'mult')
HWd_for <- forecast(HWd, h=length(test_deaths))
##### MLP #####
fitd <- mlp(train_deaths, hd.auto.type="cv", reps = 20, comb = 'median')
frcd <- forecast(fitd,h=length(test_deaths))
#| label: tbl-forecastdpdf
#| tbl-cap: "Comparación de Resultados entre las técnicas y los datos reales para evaluar precisión"
dfor <- data.frame(Date=Deaths_df$Date[126:178],
Real= test_deaths,
Forecast_HW=HWd_for$mean,
Forecast_MLP=frcd$mean)
dfor
HW_deaths <- HoltWinters(ts(Deaths_df$Deaths,frequency = 2))
HW_for_d <- forecast(HW_deaths, h=30, level=c(80,95))
#| label: tbl-pmuertespdf
#| tbl-cap: "Pronóstico de decesos por COVID-19 en Irán en los próximos 30 días"
#|
d=data.frame(Fecha=COVID.IRAN_d$Date[179:208], Decesos=round(HW_for_d$mean, 4))
d
reticulate::repl_python()
#| echo: false
import matplotlib.pyplot as plt
x = [1, 2, 3, 4, 5, 10]
p = plt.boxplot(x)
plt.show()
exit()
exit()
quit()
1750*4
#| label: fig-sm12
#| fig-cap: "LogAirPassengers con un suavizador de promedio móvil centrado de orden 12."
#| tbl-colwidths: [40, 30, 30]
library(tswge)
data(AirPassengers)
logAirPassengers=log(AirPassengers)
logair.12=ma.smooth.wge(logAirPassengers,order=12)
logair.12$smooth
logair.sm12=ts(logair.12$smooth,start=c(1949,1),frequency=12)
logair.12$smooth
logair.12$smooth
logair.12$smooth
logair.12$smooth
seas.logair=logAirPassengers-logair.sm12
round(seas.logair,4)
seas.logair=logAirPassengers-logair.sm12
round(seas.logair,4)
round(seas.logair,4)
seas.logair.numeric=as.numeric(seas.logair)
seas.logair.matrix=matrix(seas.logair.numeric,ncol=12)
seas.logair.matrix.t=t(seas.logair.matrix)
months=colMeans(seas.logair.matrix.t, na.rm=TRUE)
round(months,4)
seas.means=rep(months,12)
seas.means=ts(seas.means,start=c(1949,1),frequency=12)
#| label: tbl-forecastpdf
#| tbl-cap: "Comparación de Resultados entre las técnicas y los datos reales para evaluar precisión"
cfor
library(zoo,warn.conflicts=FALSE)
library(lubridate,warn.conflicts=FALSE)
library(mgcv,warn.conflicts=FALSE)
library(rugarch,warn.conflicts=FALSE)
# visualization
suppressPackageStartupMessages(library(ggplot2))
# getting financial data
suppressPackageStartupMessages(library(quantmod))
# calculating returns
suppressPackageStartupMessages(library(PerformanceAnalytics))
# GARCH modeling
suppressPackageStartupMessages(library(rugarch))
# ARCH test
suppressPackageStartupMessages(library(FinTS))
# ARMA modeling
suppressPackageStartupMessages(library(forecast))
# structural changes
suppressPackageStartupMessages(library(strucchange))
# ARMA order identification
suppressPackageStartupMessages(library(TSA))
library(tseries)
library(timeSeries)
library(tswge)
library(xts)
library(pastecs)
library(tidyr)
library(dplyr)
library(dygraphs)
library(splines)
library(kableExtra)
library(conflicted)
library(goeveg)
library(tidyverse)
rm(list=ls())
library(FinTS)
library(rugarch)
library(tseries)
library(dynlm)
library(vars)
library(nlWaldTest)
library(broom)
library(readxl)
library(plotly)
library(nnfor)
library(neuralnet)
# Importamos la base de datos total
COVID.19.global.data <- read.csv("WHO-COVID-19-global-data.csv")
#Dataframe de los casos confirmados en Irán
COVID.IRAN <- data.frame(Date=COVID.19.global.data$Date_reported[108535:108742],
Confirmed=COVID.19.global.data$New_cases[108535:108742])
#Dataframe de los casos confirmados en Irán del 20-02-2020 al 15-08-2020
Confirmed_df <- data.frame(COVID.IRAN[1:178,])
#Ponemos las fechas en formato 'Date'
Confirmed_df$Date <- as.Date(Confirmed_df$Date)
# Se crea un objeto 'Date' diario
inds <- seq(as.Date("2020-02-20"), as.Date("2020-08-15"), by = "day")
# Se crea un objeto 'serie de tiempo' de frecuencia diaria
Confirmed_ts <- ts(Confirmed_df[2],
start = c(2020, as.numeric(format(inds[1], "%j"))),
frequency = 365)
#| label: fig-oripdf
#| fig-cap: "Serie de tiempo de los casos de COVID-19 confirmados en Irán del 20-02-2020 al 15-08-2020."
plot(Confirmed_ts)
fig <- plot_ly(Confirmed_df, type = 'scatter', mode = 'lines')%>%
add_trace(x = ~Date, y = ~Confirmed)%>%
plotly::layout(showlegend = F)
fig <- fig %>%
plotly::layout(
xaxis = list(zerolinecolor = '#ffff',
zerolinewidth = 2,
gridcolor = 'ffff'),
yaxis = list(zerolinecolor = '#ffff',
zerolinewidth = 2,
gridcolor = 'ffff'),
plot_bgcolor='#e5ecf6')
fig
#Función para eliminar los ceros (por interpolación promedio)
for (i in 2:length(Confirmed_df$Date)-1) {
if (Confirmed_df$Confirmed[i]==0) {
Confirmed_df$Confirmed[i] <- (Confirmed_df$Confirmed[i-1]+
Confirmed_df$Confirmed[i+1])/2}}
Confirmed_ts <- ts(Confirmed_df[2],
start = c(2020, as.numeric(format(inds[1], "%j"))),
frequency = 365)
#| label: tbl-datatable
#| tbl-cap: "Casos confirmados ajustados del 20-02-2020 al 15-08-2020."
library(DT)
datatable(Confirmed_df, style = 'bootstrap4')
fig <- plot_ly(Confirmed_df, type = 'scatter', mode = 'lines')%>%
add_trace(x = ~Date, y = ~Confirmed)%>%
plotly::layout(showlegend = F)
fig <- fig %>%
plotly::layout(
xaxis = list(zerolinecolor = '#ffff',
zerolinewidth = 2,
gridcolor = 'ffff'),
yaxis = list(zerolinecolor = '#ffff',
zerolinewidth = 2,
gridcolor = 'ffff'),
plot_bgcolor='#e5ecf6')
fig
#| label: fig-tspdf
#| fig-cap: "Serie de tiempo de los casos de COVID-19 confirmados en Irán del 20-02-2020 al 15-08-2020."
plot(Confirmed_ts)
summary(Confirmed_df$Confirmed)
library(plotly)
fig <- plot_ly(Confirmed_df, y = ~Confirmed, type = 'box')
fig
adf.test(Confirmed_ts, alternative = "stationary")
autoplot(acf(Confirmed_ts, plot = FALSE),
main="Autocorrelograma de casos confirmados.")
ggPacf((Confirmed_ts), main = 'Autocorrelograma parcial de casos confirmados.')
library(tswge)
coeff <- est.ar.wge(Confirmed_ts, p=4)
coeff$phi #coeficientes
coeff$xbar #media
coeff$avar #varianza finita
Confirmed_ts <- ts(Confirmed_ts,frequency=1)
tsize <- round(0.7 * nrow(Confirmed_df))
train_confirmed <- window(Confirmed_ts,end=tsize)
test_confirmed <- window(Confirmed_ts,start=tsize+1)
DescRec <- function(x){
n = length(x)
di = rep(0, n-1)
ci = rep(0, n-1)
for (i in 1:n-1) {
di[i] = x[i+1] - x[i]
ci[i] = x[i+1] / x[i]
}
d <- cv(di)
c <- cv(ci) / mean(di)
if(d < c)
print("Se recomienda la descomposición aditiva")
else
print("Se recomienda la descomposición multiplicativa")
}
DescRec(train_confirmed)
ts_train <- ts(train_confirmed, frequency = 2)
components_ts <- decompose(ts_train, type = 'mult')
plot(components_ts)
HWc <- HoltWinters(ts_train, seasonal = 'mult')
HWc
HWc_for <- forecast(HWc, h=length(test_confirmed))
fitc <- mlp(train_confirmed, hd.auto.type="cv", reps=20, comb='median')
fitc
plot(fitc)
frcc <- forecast(fitc,h=length(test_confirmed))
#| label: tbl-forecastpdf
#| tbl-cap: "Comparación de Resultados entre las técnicas y los datos reales para evaluar precisión"
cfor
#| label: tbl-forecast
#| tbl-cap: "Comparación de Resultados entre las técnicas y los datos reales para evaluar precisión."
cfor <- data.frame(Date=Confirmed_df$Date[126:178], Real= test_confirmed,
Forecast_HW=HWc_for$mean,Forecast_MLP=frcc$mean)
DT::datatable(cfor, style = 'bootstrap4')
#| label: tbl-forecastpdf
#| tbl-cap: "Comparación de Resultados entre las técnicas y los datos reales para evaluar precisión"
cfor
#| label: tbl-forecastpdf
#| tbl-cap: "Comparación de Resultados entre las técnicas y los datos reales para evaluar precisión"
print(cfor)
cfor
library(zoo,warn.conflicts=FALSE)
library(lubridate,warn.conflicts=FALSE)
library(mgcv,warn.conflicts=FALSE)
library(rugarch,warn.conflicts=FALSE)
# visualization
suppressPackageStartupMessages(library(ggplot2))
# getting financial data
suppressPackageStartupMessages(library(quantmod))
# calculating returns
suppressPackageStartupMessages(library(PerformanceAnalytics))
# GARCH modeling
suppressPackageStartupMessages(library(rugarch))
# ARCH test
suppressPackageStartupMessages(library(FinTS))
# ARMA modeling
suppressPackageStartupMessages(library(forecast))
# structural changes
suppressPackageStartupMessages(library(strucchange))
# ARMA order identification
suppressPackageStartupMessages(library(TSA))
library(tseries)
library(timeSeries)
library(tswge)
library(xts)
library(pastecs)
library(tidyr)
library(dplyr)
library(dygraphs)
library(splines)
library(kableExtra)
library(conflicted)
library(goeveg)
library(tidyverse)
rm(list=ls())
library(FinTS)
library(rugarch)
library(tseries)
library(dynlm)
library(vars)
library(nlWaldTest)
library(broom)
library(readxl)
library(plotly)
library(nnfor)
library(neuralnet)
# Importamos la base de datos total
COVID.19.global.data <- read.csv("WHO-COVID-19-global-data.csv")
#Dataframe de los casos confirmados en Irán
COVID.IRAN <- data.frame(Date=COVID.19.global.data$Date_reported[108535:108742],
Confirmed=COVID.19.global.data$New_cases[108535:108742])
#Dataframe de los casos confirmados en Irán del 20-02-2020 al 15-08-2020
Confirmed_df <- data.frame(COVID.IRAN[1:178,])
#Ponemos las fechas en formato 'Date'
Confirmed_df$Date <- as.Date(Confirmed_df$Date)
# Se crea un objeto 'Date' diario
inds <- seq(as.Date("2020-02-20"), as.Date("2020-08-15"), by = "day")
# Se crea un objeto 'serie de tiempo' de frecuencia diaria
Confirmed_ts <- ts(Confirmed_df[2],
start = c(2020, as.numeric(format(inds[1], "%j"))),
frequency = 365)
#| label: fig-oripdf
#| fig-cap: "Serie de tiempo de los casos de COVID-19 confirmados en Irán del 20-02-2020 al 15-08-2020."
plot(Confirmed_ts)
fig <- plot_ly(Confirmed_df, type = 'scatter', mode = 'lines')%>%
add_trace(x = ~Date, y = ~Confirmed)%>%
plotly::layout(showlegend = F)
fig <- fig %>%
plotly::layout(
xaxis = list(zerolinecolor = '#ffff',
zerolinewidth = 2,
gridcolor = 'ffff'),
yaxis = list(zerolinecolor = '#ffff',
zerolinewidth = 2,
gridcolor = 'ffff'),
plot_bgcolor='#e5ecf6')
fig
#Función para eliminar los ceros (por interpolación promedio)
for (i in 2:length(Confirmed_df$Date)-1) {
if (Confirmed_df$Confirmed[i]==0) {
Confirmed_df$Confirmed[i] <- (Confirmed_df$Confirmed[i-1]+
Confirmed_df$Confirmed[i+1])/2}}
Confirmed_ts <- ts(Confirmed_df[2],
start = c(2020, as.numeric(format(inds[1], "%j"))),
frequency = 365)
#| label: tbl-datatable
#| tbl-cap: "Casos confirmados ajustados del 20-02-2020 al 15-08-2020."
library(DT)
datatable(Confirmed_df, style = 'bootstrap4')
fig <- plot_ly(Confirmed_df, type = 'scatter', mode = 'lines')%>%
add_trace(x = ~Date, y = ~Confirmed)%>%
plotly::layout(showlegend = F)
fig <- fig %>%
plotly::layout(
xaxis = list(zerolinecolor = '#ffff',
zerolinewidth = 2,
gridcolor = 'ffff'),
yaxis = list(zerolinecolor = '#ffff',
zerolinewidth = 2,
gridcolor = 'ffff'),
plot_bgcolor='#e5ecf6')
fig
#| label: fig-tspdf
#| fig-cap: "Serie de tiempo de los casos de COVID-19 confirmados en Irán del 20-02-2020 al 15-08-2020."
plot(Confirmed_ts)
summary(Confirmed_df$Confirmed)
library(plotly)
fig <- plot_ly(Confirmed_df, y = ~Confirmed, type = 'box')
fig
adf.test(Confirmed_ts, alternative = "stationary")
autoplot(acf(Confirmed_ts, plot = FALSE),
main="Autocorrelograma de casos confirmados.")
ggPacf((Confirmed_ts), main = 'Autocorrelograma parcial de casos confirmados.')
library(tswge)
coeff <- est.ar.wge(Confirmed_ts, p=4)
coeff$phi #coeficientes
coeff$xbar #media
coeff$avar #varianza finita
Confirmed_ts <- ts(Confirmed_ts,frequency=1)
tsize <- round(0.7 * nrow(Confirmed_df))
train_confirmed <- window(Confirmed_ts,end=tsize)
test_confirmed <- window(Confirmed_ts,start=tsize+1)
DescRec <- function(x){
n = length(x)
di = rep(0, n-1)
ci = rep(0, n-1)
for (i in 1:n-1) {
di[i] = x[i+1] - x[i]
ci[i] = x[i+1] / x[i]
}
d <- cv(di)
c <- cv(ci) / mean(di)
if(d < c)
print("Se recomienda la descomposición aditiva")
else
print("Se recomienda la descomposición multiplicativa")
}
DescRec(train_confirmed)
ts_train <- ts(train_confirmed, frequency = 2)
components_ts <- decompose(ts_train, type = 'mult')
plot(components_ts)
HWc <- HoltWinters(ts_train, seasonal = 'mult')
HWc
HWc_for <- forecast(HWc, h=length(test_confirmed))
fitc <- mlp(train_confirmed, hd.auto.type="cv", reps=20, comb='median')
fitc
plot(fitc)
frcc <- forecast(fitc,h=length(test_confirmed))
#| label: tbl-forecast
#| tbl-cap: "Comparación de Resultados entre las técnicas y los datos reales para evaluar precisión."
cfor <- data.frame(Date=Confirmed_df$Date[126:178], Real= test_confirmed,
Forecast_HW=HWc_for$mean,Forecast_MLP=frcc$mean)
DT::datatable(cfor, style = 'bootstrap4')
cfor
install.packages("formatR")
1800+3700+1000
#| label: fig-smap
#| fig-cap: "Datos de pasajeros aéreos con suavizado de orden 12."
library(tswge)
data(AirPassengers)
AirPass.sm12=ma.smooth.wge(AirPassengers,order=12)
AirPass.sm12=ts(AirPass.sm12$smooth,start=c(1949,1),frequency=12)
seas.AirPass=AirPassengers/AirPass.sm12
seas.AirPass.numeric=as.numeric(seas.AirPass)
seas.AirPass.matrix=matrix(seas.AirPass.numeric,ncol=12)
seas.AirPass.matrix.t=t(seas.AirPass.matrix)
months=colMeans(seas.AirPass.matrix.t,na.rm=TRUE)
seas.mean=rep(months,12)
seas.mean=ts(seas.means,start=c(1949,1),frequency=12)
seas.AirPass=AirPassengers/AirPass.sm12
seas.AirPass.numeric=as.numeric(seas.AirPass)
seas.AirPass.matrix=matrix(seas.AirPass.numeric,ncol=12)
seas.AirPass.matrix.t=t(seas.AirPass.matrix)
months=colMeans(seas.AirPass.matrix.t,na.rm=TRUE)
seas.mean=rep(months,12)
seas.mean=ts(seas.means,start=c(1949,1),frequency=12)
seas.AirPass.numeric=as.numeric(seas.AirPass)
seas.AirPass.matrix=matrix(seas.AirPass.numeric,ncol=12)
seas.AirPass.matrix.t=t(seas.AirPass.matrix)
months=colMeans(seas.AirPass.matrix.t,na.rm=TRUE)
seas.mean=rep(months,12)
seas.mean=ts(seas.mean,start=c(1949,1),frequency=12)
#| label: fig-seasmul
#| fig-cap: "Datos de AirPassengers sin el componente de tendencia y componente estacional estimado."
#| fig-subcap:
#|   - "AirPassengers Datos/tendencia"
#|   - "Componente estacional estimado"
#| layout-ncol: 2
plot(seas.AirPass)
plot(seas.mean)
seas.AirPass.numeric=as.numeric(seas.AirPass)
seas.AirPass.matrix=matrix(seas.AirPass.numeric,ncol=12)
seas.AirPass.matrix.t=t(seas.AirPass.matrix)
months=colMeans(seas.AirPass.matrix.t,na.rm=TRUE)
seas.means=rep(months,12)
seas.means=ts(seas.means,start=c(1949,1),frequency=12)
#| label: fig-descmul
#| fig-cap: 'Descomposición multiplicativa de AirPassengers.'
Air.Pass.noise = AirPassengers / (AirPass.sm12 * seas.mean)
plot(decompose(AirPassengers))
