# Crear datos de ejemplo
set.seed(1)
data <- data.frame(a = rnorm(100), b = rnorm(100))
data$y <- with(data, a + b + rnorm(100))
# Entrenar la red neuronal
nn <- neuralnet(y ~ a + b, data = data, hidden = 1)
install.packages("neuralnet")
# Graficar la red neuronal
plot(nn)
install.packages("neuralnet")
install.packages("neuralnet")
library(neuralnet)
# Crear datos de ejemplo
set.seed(1)
data <- data.frame(a = rnorm(100), b = rnorm(100))
data$y <- with(data, a + b + rnorm(100))
# Entrenar la red neuronal
nn <- neuralnet(y ~ a + b, data = data, hidden = 1)
library(diagram)
library(diagram)
# Crear un nuevo gráfico
plotmat(mat = matrix(c(0), ncol = 1), box.size = 0.05)
# Crear un nuevo gráfico
plotmat(mat = matrix(c(0), ncol = 1), box.size = 0.05)
library(diagram)
64-16
sqrt(48)
plot(Confirmed_ts)
library(zoo,warn.conflicts=FALSE)
library(lubridate,warn.conflicts=FALSE)
library(mgcv,warn.conflicts=FALSE)
library(rugarch,warn.conflicts=FALSE)
# visualization
suppressPackageStartupMessages(library(ggplot2))
# getting financial data
suppressPackageStartupMessages(library(quantmod))
# calculating returns
suppressPackageStartupMessages(library(PerformanceAnalytics))
# GARCH modeling
suppressPackageStartupMessages(library(rugarch))
# ARCH test
suppressPackageStartupMessages(library(FinTS))
# ARMA modeling
suppressPackageStartupMessages(library(forecast))
# structural changes
suppressPackageStartupMessages(library(strucchange))
# ARMA order identification
suppressPackageStartupMessages(library(TSA))
library(tseries)
library(timeSeries)
library(tswge)
library(xts)
library(pastecs)
library(tidyr)
library(dplyr)
library(dygraphs)
library(splines)
library(kableExtra)
library(conflicted)
library(goeveg)
library(tidyverse)
rm(list=ls())
library(FinTS)
library(rugarch)
library(tseries)
library(dynlm)
library(vars)
library(nlWaldTest)
library(broom)
library(readxl)
library(plotly)
library(nnfor)
library(neuralnet)
# Importamos la base de datos total
COVID.19.global.data <- read.csv("WHO-COVID-19-global-data.csv")
#Dataframe de los casos confirmados en Irán
COVID.IRAN <- data.frame(Date=COVID.19.global.data$Date_reported[108535:108742],
Confirmed=COVID.19.global.data$New_cases[108535:108742])
#Dataframe de los casos confirmados en Irán del 20-02-2020 al 15-08-2020
Confirmed_df <- data.frame(COVID.IRAN[1:178,])
#Ponemos las fechas en formato 'Date'
Confirmed_df$Date <- as.Date(Confirmed_df$Date)
# Se crea un objeto 'Date' diario
inds <- seq(as.Date("2020-02-20"), as.Date("2020-08-15"), by = "day")
# Se crea un objeto 'serie de tiempo' de frecuencia diaria
Confirmed_ts <- ts(Confirmed_df[2],
start = c(2020, as.numeric(format(inds[1], "%j"))),
frequency = 365)
plot(Confirmed_ts)
fig <- plot_ly(Confirmed_df, type = 'scatter', mode = 'lines')%>%
add_trace(x = ~Date, y = ~Confirmed)%>%
plotly::layout(showlegend = F)
fig <- fig %>%
plotly::layout(
xaxis = list(zerolinecolor = '#ffff',
zerolinewidth = 2,
gridcolor = 'ffff'),
yaxis = list(zerolinecolor = '#ffff',
zerolinewidth = 2,
gridcolor = 'ffff'),
plot_bgcolor='#e5ecf6')
fig
plot(Confirmed_ts~inds)
plot(Confirmed_ts)
library(tswge)
plotts.wge(Confirmed_ts)
plot(Confirmed_ts)
# Se crea un objeto 'Date' diario
inds <- seq(as.Date("2020-02-20"), as.Date("2020-08-15"), by = "day")
# Se crea un objeto 'serie de tiempo' de frecuencia diaria
Confirmed_ts <- ts(Confirmed_df[2],
start = c(2020, as.numeric(format(inds[1], "%j"))),
frequency = 365)
library(tswge)
plotts.wge(Confirmed_ts)
plot(Confirmed_ts)
library(tswge)
plot(Confirmed_ts)
#| label: fig-oripdf
#| tbl-cap: "Serie de tiempo de los casos de COVID-19 confirmados en Irán del 20-02-2020 al 15-08-2020"
library(tswge)
plot(Confirmed_ts)
Confirmed_df
#| label: tbl-forecast
#| tbl-cap: "Comparación de Resultados entre las técnicas y los datos reales para evaluar precisión"
#|
cfor <- data.frame(Date=Confirmed_df$Date[126:178], Real= test_confirmed,
Forecast_HW=HWc_for$mean,Forecast_MLP=frcc$mean)
library(zoo,warn.conflicts=FALSE)
library(lubridate,warn.conflicts=FALSE)
library(mgcv,warn.conflicts=FALSE)
library(rugarch,warn.conflicts=FALSE)
# visualization
suppressPackageStartupMessages(library(ggplot2))
# getting financial data
suppressPackageStartupMessages(library(quantmod))
# calculating returns
suppressPackageStartupMessages(library(PerformanceAnalytics))
# GARCH modeling
suppressPackageStartupMessages(library(rugarch))
# ARCH test
suppressPackageStartupMessages(library(FinTS))
# ARMA modeling
suppressPackageStartupMessages(library(forecast))
# structural changes
suppressPackageStartupMessages(library(strucchange))
# ARMA order identification
suppressPackageStartupMessages(library(TSA))
library(tseries)
library(timeSeries)
library(tswge)
library(xts)
library(pastecs)
library(tidyr)
library(dplyr)
library(dygraphs)
library(splines)
library(kableExtra)
library(conflicted)
library(goeveg)
library(tidyverse)
rm(list=ls())
library(FinTS)
library(rugarch)
library(tseries)
library(dynlm)
library(vars)
library(nlWaldTest)
library(broom)
library(readxl)
library(plotly)
library(nnfor)
library(neuralnet)
# Importamos la base de datos total
COVID.19.global.data <- read.csv("WHO-COVID-19-global-data.csv")
#Dataframe de los casos confirmados en Irán
COVID.IRAN <- data.frame(Date=COVID.19.global.data$Date_reported[108535:108742],
Confirmed=COVID.19.global.data$New_cases[108535:108742])
#Dataframe de los casos confirmados en Irán del 20-02-2020 al 15-08-2020
Confirmed_df <- data.frame(COVID.IRAN[1:178,])
#Ponemos las fechas en formato 'Date'
Confirmed_df$Date <- as.Date(Confirmed_df$Date)
# Se crea un objeto 'Date' diario
inds <- seq(as.Date("2020-02-20"), as.Date("2020-08-15"), by = "day")
# Se crea un objeto 'serie de tiempo' de frecuencia diaria
Confirmed_ts <- ts(Confirmed_df[2],
start = c(2020, as.numeric(format(inds[1], "%j"))),
frequency = 365)
#| label: fig-oripdf
#| fig-cap: "Serie de tiempo de los casos de COVID-19 confirmados en Irán del 20-02-2020 al 15-08-2020"
plot(Confirmed_ts)
fig <- plot_ly(Confirmed_df, type = 'scatter', mode = 'lines')%>%
add_trace(x = ~Date, y = ~Confirmed)%>%
plotly::layout(showlegend = F)
fig <- fig %>%
plotly::layout(
xaxis = list(zerolinecolor = '#ffff',
zerolinewidth = 2,
gridcolor = 'ffff'),
yaxis = list(zerolinecolor = '#ffff',
zerolinewidth = 2,
gridcolor = 'ffff'),
plot_bgcolor='#e5ecf6')
fig
#Función para eliminar los ceros (por interpolación promedio)
for (i in 2:length(Confirmed_df$Date)-1) {
if (Confirmed_df$Confirmed[i]==0) {
Confirmed_df$Confirmed[i] <- (Confirmed_df$Confirmed[i-1]+
Confirmed_df$Confirmed[i+1])/2}}
Confirmed_ts <- ts(Confirmed_df[2],
start = c(2020, as.numeric(format(inds[1], "%j"))),
frequency = 365)
#| label: tbl-datatable
#| tbl-cap: "Casos confirmados ajustados del 20-02-2020 al 15-08-2020"
library(DT)
datatable(Confirmed_df, style = 'bootstrap4')
fig <- plot_ly(Confirmed_df, type = 'scatter', mode = 'lines')%>%
add_trace(x = ~Date, y = ~Confirmed)%>%
plotly::layout(showlegend = F)
fig <- fig %>%
plotly::layout(
xaxis = list(zerolinecolor = '#ffff',
zerolinewidth = 2,
gridcolor = 'ffff'),
yaxis = list(zerolinecolor = '#ffff',
zerolinewidth = 2,
gridcolor = 'ffff'),
plot_bgcolor='#e5ecf6')
fig
#| label: fig-tspdf
#| fig-cap: "Serie de tiempo de los casos de COVID-19 confirmados en Irán del 20-02-2020 al 15-08-2020"
plot(Confirmed_ts)
summary(Confirmed_df$Confirmed)
library(plotly)
fig <- plot_ly(Confirmed_df, y = ~Confirmed, type = 'box')
fig
adf.test(Confirmed_ts, alternative = "stationary")
autoplot(acf(Confirmed_ts, plot = FALSE),
main="Autocorrelograma de casos confirmados")
ggPacf((Confirmed_ts), main = 'Autocorrelograma parcial de casos confirmados')
library(tswge)
coeff <- est.ar.wge(Confirmed_ts, p=4)
coeff$phi #coeficientes
coeff$xbar #media
coeff$avar #varianza finita
Confirmed_ts <- ts(Confirmed_ts,frequency=1)
tsize <- round(0.7 * nrow(Confirmed_df))
train_confirmed <- window(Confirmed_ts,end=tsize)
test_confirmed <- window(Confirmed_ts,start=tsize+1)
DescRec <- function(x){
n = length(x)
di = rep(0, n-1)
ci = rep(0, n-1)
for (i in 1:n-1) {
di[i] = x[i+1] - x[i]
ci[i] = x[i+1] / x[i]
}
d <- cv(di)
c <- cv(ci) / mean(di)
if(d < c)
print("Se recomienda la descomposición aditiva")
else
print("Se recomienda la descomposición multiplicativa")
}
DescRec(train_confirmed)
ts_train <- ts(train_confirmed, frequency = 2)
components_ts <- decompose(ts_train, type = 'mult')
plot(components_ts)
HWc <- HoltWinters(ts_train, seasonal = 'mult')
HWc
HWc_for <- forecast(HWc, h=length(test_confirmed))
fitc <- mlp(train_confirmed, hd.auto.type="cv", reps = 20, comb = 'median')
fitc
plot(fitc)
frcc <- forecast(fitc,h=length(test_confirmed))
#| label: tbl-forecast
#| tbl-cap: "Comparación de Resultados entre las técnicas y los datos reales para evaluar precisión"
#|
cfor <- data.frame(Date=Confirmed_df$Date[126:178], Real= test_confirmed,
Forecast_HW=HWc_for$mean,Forecast_MLP=frcc$mean)
DT::datatable(cfor, style = 'bootstrap4')
#| label: tbl-forecastpdf
#| tbl-cap: "Comparación de Resultados entre las técnicas y los datos reales para evaluar precisión"
cfor
#| label: tbl-treintapdf
#| tbl-cap: "Pronóstico de casos confirmados de COVID-19 en Irán en los próximos 30 días"
#|
d=data.frame(Fecha=COVID.IRAN$Date[179:208], Infectados=round(fore.mlp$mean,3))
##### Training and Testing Errores #####
HW_train = generics::accuracy(train_confirmed[3:125], HWc_for$fitted[3:125])[1,1:5]
HW_test = generics::accuracy(cfor$Confirmed, cfor$Forecast_HW)[1,1:5]
MLP_train = generics::accuracy(train_confirmed[5:125], frcc$fitted)[1,1:5]
MLP_test = generics::accuracy(cfor$Confirmed, cfor$Forecast_MLP)[1,1:5]
Training_Data <- data.frame(
RMSE = c(HW_train[2], MLP_train[2]),
MAE = c(HW_train[3], MLP_train[3]),
MAPE = c(HW_train[5], MLP_train[5]),
row.names = c("Holt-Winters", "MLP")
)
Testing_Data <- data.frame(
RMSE = c(HW_test[2], MLP_test[2]),
MAE = c(HW_test[3], MLP_test[3]),
MAPE = c(HW_test[5], MLP_test[5]),
row.names = c("Holt-Winters", "MLP")
)
Confirmed_Cases <- data.frame(Trainig = Training_Data, Testing =Testing_Data)
#Confirmed_Cases
fit.mlp = mlp(ts(Confirmed_df$Confirmed), reps = 20, hd.auto.type = 'cv',
comb="median")
fore.mlp = forecast(fit.mlp, h = 30)
plot(fore.mlp)
#| label: tbl-treintapdf
#| tbl-cap: "Pronóstico de casos confirmados de COVID-19 en Irán en los próximos 30 días"
#|
d=data.frame(Fecha=COVID.IRAN$Date[179:208], Infectados=round(fore.mlp$mean,3))
d
library(zoo,warn.conflicts=FALSE)
library(lubridate,warn.conflicts=FALSE)
library(mgcv,warn.conflicts=FALSE)
library(rugarch,warn.conflicts=FALSE)
# visualization
suppressPackageStartupMessages(library(ggplot2))
# getting financial data
suppressPackageStartupMessages(library(quantmod))
# calculating returns
suppressPackageStartupMessages(library(PerformanceAnalytics))
# GARCH modeling
suppressPackageStartupMessages(library(rugarch))
# ARCH test
suppressPackageStartupMessages(library(FinTS))
# ARMA modeling
suppressPackageStartupMessages(library(forecast))
# structural changes
suppressPackageStartupMessages(library(strucchange))
# ARMA order identification
suppressPackageStartupMessages(library(TSA))
library(tseries)
library(timeSeries)
library(tswge)
library(xts)
library(pastecs)
library(tidyr)
library(dplyr)
library(dygraphs)
library(splines)
library(kableExtra)
library(conflicted)
library(goeveg)
library(tidyverse)
rm(list=ls())
library(FinTS)
library(rugarch)
library(tseries)
library(dynlm)
library(vars)
library(nlWaldTest)
library(broom)
library(readxl)
library(plotly)
library(nnfor)
library(neuralnet)
# Importamos la base de datos total
COVID.19.global.data <- read.csv("WHO-COVID-19-global-data.csv")
#Dataframe de los casos confirmados en Irán
COVID.IRAN_d <- data.frame(Date=COVID.19.global.data$Date_reported[108535:108742],
Deaths=COVID.19.global.data$New_deaths[108535:108742])
#Dataframe de los casos confirmados en Irán del 20-02-2020 al 15-08-2020
Deaths_df <- data.frame(COVID.IRAN_d[1:178,])
#Función para eliminar los ceros (por interpolación promedio)
for (i in 2:length(Deaths_df$Date)-1) {
if (Deaths_df$Deaths[i]==0) {
Deaths_df$Deaths[i] <- (Deaths_df$Deaths[i-1]+
Deaths_df$Deaths[i+1])/2}}
inds <- seq(as.Date("2020-02-20"), as.Date("2020-08-15"), by = "day")
# Se crea un objeto 'serie de tiempo' de frecuencia diaria
Deaths_ts <- ts(Deaths_df[2],
start = c(2020, as.numeric(format(inds[1], "%j"))),
frequency = 365)
fig <- plot_ly(Deaths_df, type = 'scatter', mode = 'lines')%>%
add_trace(x = ~Date, y = ~Deaths)%>%
plotly::layout(showlegend = F)
fig <- fig %>%
plotly::layout(
xaxis = list(zerolinecolor = '#ffff',
zerolinewidth = 2,
gridcolor = 'ffff'),
yaxis = list(zerolinecolor = '#ffff',
zerolinewidth = 2,
gridcolor = 'ffff'),
plot_bgcolor='#e5ecf6')
fig
#| label: fig-muertespdf
#| fig-cap: "Serie de tiempo de los casos de muerte por COVID-19 en Irán del 20-02-2020 al 15-08-2020"
plot(Deaths_ts)
#| label: tbl-forecastdpdf
#| tbl-cap: "Comparación de Resultados entre las técnicas y los datos reales para evaluar precisión"
dfor <- data.frame(Date=Deaths_df$Date[126:178],
Real= test_deaths,
Forecast_HW=HWd_for$mean,
Forecast_MLP=frcd$mean)
library(zoo,warn.conflicts=FALSE)
library(lubridate,warn.conflicts=FALSE)
library(mgcv,warn.conflicts=FALSE)
library(rugarch,warn.conflicts=FALSE)
# visualization
suppressPackageStartupMessages(library(ggplot2))
# getting financial data
suppressPackageStartupMessages(library(quantmod))
# calculating returns
suppressPackageStartupMessages(library(PerformanceAnalytics))
# GARCH modeling
suppressPackageStartupMessages(library(rugarch))
# ARCH test
suppressPackageStartupMessages(library(FinTS))
# ARMA modeling
suppressPackageStartupMessages(library(forecast))
# structural changes
suppressPackageStartupMessages(library(strucchange))
# ARMA order identification
suppressPackageStartupMessages(library(TSA))
library(tseries)
library(timeSeries)
library(tswge)
library(xts)
library(pastecs)
library(tidyr)
library(dplyr)
library(dygraphs)
library(splines)
library(kableExtra)
library(conflicted)
library(goeveg)
library(tidyverse)
rm(list=ls())
library(FinTS)
library(rugarch)
library(tseries)
library(dynlm)
library(vars)
library(nlWaldTest)
library(broom)
library(readxl)
library(plotly)
library(nnfor)
library(neuralnet)
# Importamos la base de datos total
COVID.19.global.data <- read.csv("WHO-COVID-19-global-data.csv")
#Dataframe de los casos confirmados en Irán
COVID.IRAN_d <- data.frame(Date=COVID.19.global.data$Date_reported[108535:108742],
Deaths=COVID.19.global.data$New_deaths[108535:108742])
#Dataframe de los casos confirmados en Irán del 20-02-2020 al 15-08-2020
Deaths_df <- data.frame(COVID.IRAN_d[1:178,])
#Función para eliminar los ceros (por interpolación promedio)
for (i in 2:length(Deaths_df$Date)-1) {
if (Deaths_df$Deaths[i]==0) {
Deaths_df$Deaths[i] <- (Deaths_df$Deaths[i-1]+
Deaths_df$Deaths[i+1])/2}}
inds <- seq(as.Date("2020-02-20"), as.Date("2020-08-15"), by = "day")
# Se crea un objeto 'serie de tiempo' de frecuencia diaria
Deaths_ts <- ts(Deaths_df[2],
start = c(2020, as.numeric(format(inds[1], "%j"))),
frequency = 365)
fig <- plot_ly(Deaths_df, type = 'scatter', mode = 'lines')%>%
add_trace(x = ~Date, y = ~Deaths)%>%
plotly::layout(showlegend = F)
fig <- fig %>%
plotly::layout(
xaxis = list(zerolinecolor = '#ffff',
zerolinewidth = 2,
gridcolor = 'ffff'),
yaxis = list(zerolinecolor = '#ffff',
zerolinewidth = 2,
gridcolor = 'ffff'),
plot_bgcolor='#e5ecf6')
fig
#| label: fig-muertespdf
#| fig-cap: "Serie de tiempo de los casos de muerte por COVID-19 en Irán del 20-02-2020 al 15-08-2020"
plot(Deaths_ts)
Deaths_ts <- ts(Deaths_ts,frequency=1)
tsize <- round(0.7 * nrow(Deaths_df))
train_deaths <- window(Deaths_ts,end=tsize)
test_deaths <- window(Deaths_ts,start=tsize+1)
##### HW #####
HWd <- HoltWinters(ts(train_deaths,frequency = 2), seasonal = 'mult')
HWd_for <- forecast(HWd, h=length(test_deaths))
##### MLP #####
fitd <- mlp(train_deaths, hd.auto.type="cv", reps = 20, comb = 'median')
frcd <- forecast(fitd,h=length(test_deaths))
#| label: tbl-forecastdpdf
#| tbl-cap: "Comparación de Resultados entre las técnicas y los datos reales para evaluar precisión"
dfor <- data.frame(Date=Deaths_df$Date[126:178],
Real= test_deaths,
Forecast_HW=HWd_for$mean,
Forecast_MLP=frcd$mean)
dfor
HW_deaths <- HoltWinters(ts(Deaths_df$Deaths,frequency = 2))
HW_for_d <- forecast(HW_deaths, h=30, level=c(80,95))
#| label: tbl-pmuertespdf
#| tbl-cap: "Pronóstico de decesos por COVID-19 en Irán en los próximos 30 días"
#|
d=data.frame(Fecha=COVID.IRAN_d$Date[179:208], Decesos=round(HW_for_d$mean, 4))
d
reticulate::repl_python()
#| echo: false
import matplotlib.pyplot as plt
x = [1, 2, 3, 4, 5, 10]
p = plt.boxplot(x)
plt.show()
exit()
exit()
quit()
1750*4
