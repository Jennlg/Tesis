---
title: "matplotlib demo"
lang: es
---

For a demonstration of a line plot on a polar axis, see @fig-polar.

```{python}
#| label: fig-polar
#| fig-cap: "A line plot on a polar axis"

import numpy as np
import matplotlib.pyplot as plt

r = np.arange(0, 2, 0.01)
theta = 2 * np.pi * r
fig, ax = plt.subplots(
  subplot_kw = {'projection': 'polar'} 
)
ax.plot(theta, r)
ax.set_rticks([0.5, 1, 1.5, 2])
ax.grid(True)
plt.show()
```

Vea la @fig-mlp

```{python}
#| warning: false
#| error: false
#| label: fig-mlp
#| fig-cap: "Pronóstico de casos confirmados de COVID-19 en Irán en los próximos 30 días (implementación en python)"
import numpy as np
import pandas as pd
import yfinance as yf
import tensorflow as tf
import matplotlib.pyplot as plt
import plotly.express as px
import plotly.graph_objects as go
from tensorflow.keras.layers import Dense, LSTM
from tensorflow.keras.models import Sequential
from sklearn.preprocessing import MinMaxScaler

pd.options.mode.chained_assignment = None
tf.random.set_seed(0)
df = pd.read_excel('Data.xlsx')

# ------------- Entrenamiento y prueba del modelo --------------
y = df['Confirmed'].fillna(method='ffill')
y = y.values.reshape(-1, 1)
# scale the data
scaler = MinMaxScaler(feature_range=(0, 1))
scaler = scaler.fit(y)
y = scaler.transform(y)

# generate the input and output sequences
n_lookback = 53  # length of input sequences (lookback period)
n_forecast = 30  # length of output sequences (forecast period)

X = []
Y = []

for i in range(n_lookback, len(y) - n_forecast + 1):
    X.append(y[i - n_lookback: i])
    Y.append(y[i: i + n_forecast])

X = np.array(X)
Y = np.array(Y)

# fit the model
model = Sequential()
model.add(Dense(20, activation='sigmoid', input_dim=n_lookback))
model.add(Dense(n_forecast))

model.compile(loss='mean_squared_error', optimizer='adam')
model.fit(X, Y, epochs=20, batch_size=4, verbose=0)

# generate the forecasts
X_ = y[- n_lookback:]  # last available input sequence
X_ = X_.reshape(1, n_lookback, 1)

Y_ = model.predict(X_).reshape(-1, 1)
Y_ = scaler.inverse_transform(Y_)

# organize the results in a data frame
df_past = df
df_past.rename(columns={'Date': 'Date', 'Confirmed': 'Actual'}, inplace=True)
df_past['Date'] = pd.to_datetime(df_past['Date'])
df_past['Forecast'] = np.nan
df_past['Forecast'].iloc[-1] = df_past['Actual'].iloc[-1]

df_future = pd.DataFrame(columns=['Date', 'Actual', 'Forecast'])
df_future['Date'] = pd.date_range(start=df_past['Date'].iloc[-1] + pd.Timedelta(days=1), periods=n_forecast)
df_future['Forecast'] = Y_.flatten()
df_future['Actual'] = np.nan

results = df_past._append(df_future).set_index('Date')
# Calculate minimum, median, and maximum for each forecasted date
results['Min'] = results['Forecast'].rolling(window=2).min()
results['Max'] = results['Forecast'].rolling(window=2).max()
results['Median'] = results['Forecast'].rolling(window=2).median()

# Creamos la gráfica con las predicciones
fig = px.line(results, x=results.index, y=['Actual','Forecast', 'Median'],
#fig = px.line(results, x=results.index, y=['Actual', 'Median'],
              labels={'index': 'Date', 'value': 'Confirmed Cases'},
              title='Casos Confirmados',
              line_shape='linear')

fig.update_traces(line=dict(color='cornflowerblue'), selector=dict(name='Actual'))
fig.update_traces(line=dict(color='orange'), selector=dict(name='Forecast'))
fig.update_traces(line=dict(color='mediumvioletred'), selector=dict(name='Median'))

# Agregar gráficos de área para el mínimo y el máximo
fig.add_trace(
    go.Scatter(x=results.index, y=results['Min'], fill=None, mode='lines', line=dict(color='hotpink'), name='Min')
)
fig.add_trace(
    go.Scatter(x=results.index, y=results['Max'], fill='tonexty', mode='lines', line=dict(color='deeppink'), name='Max')
)
fig.show()
```
